;;; -*- lexical-binding: t -*-
#+PROPERTY: header-args:emacs-lisp :tangle yes :lexical t
* Emacs Configuration.. semi-literate
** Packages
*** Custom file location
custom and the way it stores items in init.el is one of the dumber things
emacs does. well whatever, we move it
#+begin_src emacs-lisp
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (load custom-file 'noerror)
#+end_src

** Performance
*** Measuring startup speed
Function copied from sqrtminusone's config, measures emacs startup time.
#+begin_src emacs-lisp
  (defvar my/emacs-started nil
    "Flag to track whether Emacs has completed startup.")

  (add-hook 'emacs-startup-hook
            (lambda ()
              (message "*** Emacs loaded in %s with %d garbage collections."
  	                   (format "%.2f seconds"
  		                         (float-time
  			                        (time-subtract after-init-time before-init-time)))
  	                   gcs-done)
              (setq my/emacs-started t)))
#+end_src

*** Garbage collection
#+begin_src emacs-lisp
  (setq gc-cons-threshold 100000000)
  (setq read-process-output-max (* 1024 1024))
#+end_src

*** exec-path-from-shell
This conditionally sets the shell path based on the users configured shell path on boot.
Pretty good.
#+begin_src emacs-lisp
  (use-package exec-path-from-shell

    :init
    (require 'exec-path-from-shell)
    (dolist (var '("SSH_AUTH_SOCK" "SSH_AGENT_PID" "GPG_AGENT_INFO" "LANG" "LC_CTYPE" "NIX_SSL_CERT_FILE" "NIX_PATH"))
      (add-to-list 'exec-path-from-shell-variables var))
    (when (daemonp)
      (exec-path-from-shell-initialize))
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))
#+end_src

** Config Files
Turns out, there's a feature called file locking that's used for multi-user scenarios. That sucks.
#+begin_src emacs-lisp
  (setq lock-file-name-transforms
        '(("\\`/.*/\\([^/]+\\)\\'" "~/.emacs.d/.cache/\\1" t)))
  (setq auto-save-file-name-transforms
        '(("\\`/.*/\\([^/]+\\)\\'" "~/.emacs.d/.cache/\\1" t)))
  (setq backup-directory-alist
        '((".*" . "~/.emacs.d/.cache/")))
#+end_src

*** Make it harder to kill emacs
This will prompt us when we're going to kill Emacs.
#+begin_src emacs-lisp
  (unless (daemonp)
    (setq confirm-kill-emacs 'y-or-n-p))
#+end_src

** General settings
*** Emacs
#+begin_src emacs-lisp
  (use-package emacs
    :custom
    ;; Enable context menu. `vertico-multiform-mode' adds a menu in the minibuffer
    ;; to switch display modes.
    (context-menu-mode t)
    ;; Support opening new minibuffers from inside existing minibuffers.
    (enable-recursive-minibuffers t)
    ;; Hide commands in M-x which do not work in the current mode.  Vertico
    ;; commands are hidden in normal buffers. This setting is useful beyond
    ;; Vertico.
    (read-extended-command-predicate #'command-completion-default-include-p)
    ;; Do not allow the cursor in the minibuffer prompt
    (minibuffer-prompt-properties
     '(read-only t cursor-intangible t face minibuffer-prompt))
    ;; Enable indentation+completion using the TAB key.
    ;; `completion-at-point' is often bound to M-TAB.
    (tab-always-indent 'complete)

    ;; Emacs 30 and newer: Disable Ispell completion function.
    ;; Try `cape-dict' as an alternative.
    (text-mode-ispell-word-completion nil))
#+end_src

*** Keybindings
**** multiple-cursors
#+begin_src emacs-lisp
  (use-package multiple-cursors
    :bind
    (("C-S-c C-S-c" . mc/edit-lines)
     ("C->" . mc/mark-next-like-this)
     ("C-<" . mc/mark-previous-like-this)
     ("C-c C-<" . mc/mark-all-like-this)
     ("C-\"" . mc/skip-to-next-like-this)
     ("C-:" . mc/skip-to-previous-like-this)))
#+end_src

**** zap mode
very useful replacement for dt<char> from vim
#+begin_src emacs-lisp
  (global-set-key [remap zap-to-char]
                  'zap-up-to-char)
#+end_src

**** which-key
A package that displays the available keybindings in a popup.
The package is pretty useful, as Emacs seems to have more keybindings than
I can remember at any given point.
#+begin_src emacs-lisp
  (use-package which-key
    :config
    (setq which-key-idle-delay 0.3)
    (setq which-key-popup-type 'frame)
    (which-key-mode)
    (which-key-setup-side-window-bottom)
    (set-face-attribute 'which-key-local-map-description-face nil
                        :weight 'bold)
    )
#+end_src
**** dumb-jump / xref
#+begin_src emacs-lisp
  (use-package dumb-jump
    :config
    (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
    (setq xref-show-definitions-function #'xref-show-definitions-completing-read))
  (setq xref-search-program 'ripgrep)
#+end_src

*** Theme
**** nano
#+BEGIN_SRC emacs-lisp
  (use-package nano-theme
    :config
    (load-theme 'nano-light t)
    (add-hook 'prog-mode-hook            #'nano-modeline-prog-mode)
    (add-hook 'text-mode-hook            #'nano-modeline-text-mode)
    (add-hook 'org-mode-hook             #'nano-modeline-org-mode)
    (add-hook 'pdf-view-mode-hook        #'nano-modeline-pdf-mode)
    (add-hook 'mu4e-headers-mode-hook    #'nano-modeline-mu4e-headers-mode)
    (add-hook 'mu4e-view-mode-hook       #'nano-modeline-mu4e-message-mode)
    (add-hook 'elfeed-show-mode-hook     #'nano-modeline-elfeed-entry-mode)
    (add-hook 'elfeed-search-mode-hook   #'nano-modeline-elfeed-search-mode)
    (add-hook 'term-mode-hook            #'nano-modeline-term-mode)
    (add-hook 'xwidget-webkit-mode-hook  #'nano-modeline-xwidget-mode)
    (add-hook 'messages-buffer-mode-hook #'nano-modeline-message-mode)
    (add-hook 'org-capture-mode-hook     #'nano-modeline-org-capture-mode)
    (add-hook 'org-agenda-mode-hook      #'nano-modeline-org-agenda-mode))
#+END_SRC

**** Font
#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(font . "Berkeley Mono 16"))
  (set-face-attribute 'default        nil :family "Berkeley Mono" :height 120 :weight 'medium)
  (set-face-attribute 'fixed-pitch    nil :family "Berkeley Mono" :height 120 :weight 'medium)
  (set-face-attribute 'variable-pitch nil :family "Berkeley Mono" :height 120 :weight 'normal)
#+end_src


**** Default Frame Parameters
#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
  (add-to-list 'default-frame-alist '(ns-appearance . dark))
#+end_src

**** visual bell only
#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
  (setq visible-bell t)
#+end_src

#+RESULTS:
: visual-bell

**** Dashboard
#+begin_src emacs-lisp
  (use-package dashboard
    :config
    (dashboard-setup-startup-hook))
#+end_src

*** Programming Modes
**** C/C++
#+begin_src emacs-lisp
  (use-package simpc-mode
    :ensure nil
    :mode "\\.[hc]\\(pp\\)?\\'")
#+end_src

**** nix
#+begin_src emacs-lisp
  (use-package nix-mode
    :mode "\\.nix\\'"
    :hook (nix-mode . lsp-deferred))
  (use-package nix-ts-mode
    :mode "\\.nix\\'")
#+end_src

**** Rust
***** rust-mode
#+begin_src emacs-lisp
  (use-package rust-mode

    :config
    (setq rust-mode-treesitter-derive t)
    (setq rust-format-on-save t)
    (add-hook 'rust-mode-hook (lambda () (setq indent-tabs-mode nil)))
    (add-hook 'rust-mode-hook (lambda () (prettify-symbols-mode))))
#+end_src

**** Fish Shell
#+begin_src emacs-lisp
  (use-package fish-mode
    :mode "\\.fish\\'")
#+end_src

**** Haskell
#+begin_src emacs-lisp
  (use-package haskell-mode
    :mode "\\.hs\\'")
#+end_src

**** Terraform
#+begin_src emacs-lisp
  (use-package terraform-mode

    :custom (terraform-format-on-save t)
    :config
    (defun my-terraform-mode-init ()
      ;; if you want to use outline-minor-mode
      (outline-minor-mode 1))
    (add-hook 'terraform-mode-hook 'my-terraform-mode-init))
#+end_src

**** Dockerfile
#+begin_src emacs-lisp
  (use-package dockerfile-mode)
#+end_src

**** Groovy
#+begin_src emacs-lisp
  (use-package groovy-mode)
#+end_src

**** LSP
#+begin_src emacs-lisp
  (use-package eglot
    :config
    ;; Ensure `nil` is in your PATH.
    (add-to-list 'eglot-server-programs '(nix-mode . ("nil")))
    :hook
    (nix-mode . eglot-ensure)
    (terraform-mode . eglot-ensure)
    (haskell-mode . eglot-ensure)
    (rust-mode . eglot-ensure)
    (fish-mode . eglot-ensure)
    (typescript-mode . eglot-ensure)
    (go-mode . eglot-ensure)
    (yaml-mode . eglot-ensure)
    (ruby-mode. eglot-ensure)
    (dockerfile-mode . eglot-ensure)
    (groovy-mode . eglot-ensure)
    (zig-mode . eglot-ensure))
#+end_src

**** Flycheck
#+begin_src emacs-lisp
  (use-package flycheck
    :init (global-flycheck-mode))
  (use-package flycheck-eglot
    :after (flycheck eglot)
    :config (global-flycheck-eglot-mode 1))
#+end_src

**** Corfu
#+begin_src emacs-lisp
  (use-package corfu-terminal)
  (use-package corfu
    :init
    (global-corfu-mode)
    (corfu-popupinfo-mode)
    (unless (display-graphic-p)
      (corfu-terminal-mode +1))
    :config
    (setq corfu-auto t
          corfu-quit-no-match 'separator
          corfu-auto-delay 0.2
          corfu-min-width 20
          corfu-max-width 80
          corfu-bar-width 0
          corfu-border-width 1))
  (use-package cape
    ;; Bind prefix keymap providing all Cape commands under a mnemonic key.
    ;; Press C-c p ? to for help.
    :bind ("C-c p" . cape-prefix-map) ;; Alternative key: M-<tab>, M-p, M-+
    ;; Alternatively bind Cape commands individually.
    ;; :bind (("C-c p d" . cape-dabbrev)
    ;;        ("C-c p h" . cape-history)
    ;;        ("C-c p f" . cape-file)
    ;;        ...)
    :init
    ;; Add to the global default value of `completion-at-point-functions' which is
    ;; used by `completion-at-point'.  The order of the functions matters, the
    ;; first function returning a result wins.  Note that the list of buffer-local
    ;; completion functions takes precedence over the global list.
    (add-hook 'completion-at-point-functions #'cape-dabbrev)
    (add-hook 'completion-at-point-functions #'cape-file)
    (add-hook 'completion-at-point-functions #'cape-elisp-block)
    ;; (add-hook 'completion-at-point-functions #'cape-history)
    ;; ...
    )
                  #+end_src

**** minuet (ai autocomplete)
#+begin_src emacs-lisp
  ;; (use-package minuet
  ;;   :config
  ;;   (setq minuet-provider 'openai-fim-compatible)
  ;;   (setq minuet-n-completions 1) ; recommended for Local LLM for resource saving
  ;;   ;; I recommend beginning with a small context window size and incrementally
  ;;   ;; expanding it, depending on your local computing power. A context window
  ;;   ;; of 512, serves as an good starting point to estimate your computing
  ;;   ;; power. Once you have a reliable estimate of your local computing power,
  ;;   ;; you should adjust the context window to a larger value.
  ;;   (setq minuet-context-window 8192)
  ;;   (plist-put minuet-openai-fim-compatible-options :end-point "http://cerebro:8080/v1/completions")
  ;;   ;; an arbitrary non-null environment variable as placeholder
  ;;   ;; For Windows users, TERM may not be present in environment variables.
  ;;   ;; Consider using APPDATA instead.
  ;;   (plist-put minuet-openai-fim-compatible-options :name "Llama.cpp")
  ;;   (plist-put minuet-openai-fim-compatible-options :api-key "TERM")
  ;;   ;; The model is set by the llama-cpp server and cannot be altered
  ;;   ;; post-launch.
  ;;   (plist-put minuet-openai-fim-compatible-options :model "PLACEHOLDER")

  ;;   ;; Llama.cpp does not support the `suffix` option in FIM completion.
  ;;   ;; Therefore, we must disable it and manually populate the special
  ;;   ;; tokens required for FIM completion.
  ;;   (minuet-set-nested-plist minuet-openai-fim-compatible-options nil :template :suffix)
  ;;   (minuet-set-optional-options
  ;;    minuet-openai-fim-compatible-options
  ;;    :prompt
  ;;    (defun minuet-llama-cpp-fim-qwen-prompt-function (ctx)
  ;;      (format "<|fim_prefix|>%s\n%s<|fim_suffix|>%s<|fim_middle|>"
  ;;              (plist-get ctx :language-and-tab)
  ;;              (plist-get ctx :before-cursor)
  ;;              (plist-get ctx :after-cursor)))
  ;;    :template)

  ;;   (minuet-set-optional-options minuet-openai-fim-compatible-options :max_tokens 56))
#+end_src

**** Typescript
#+begin_src emacs-lisp
  (use-package typescript-mode
    :mode "\\.ts\\'"
    :config
    (add-hook 'typescript-mode-hook #'hs-minor-mode))
#+end_src

**** go-mode
#+begin_src emacs-lisp
  (use-package go-mode
    :mode "\\.go\\'"
    :hook (before-save . gofmt-before-save)
    :custom (gofmt-command "goimports"))
#+end_src

**** yaml-mode
#+begin_src emacs-lisp
  (use-package yaml-mode
    :mode "\\.yml\\'")
#+end_src

**** ruby-mode
#+begin_src emacs-lisp
  (use-package ruby-mode
    :ensure nil
    :mode "\\.\\(?:cap\\|gemspec\\|irbrc\\|gemrc\\|rake\\|rb\\|ru\\|thor\\)\\'"
    :mode "\\(?:Brewfile\\|Capfile\\|Gemfile\\(?:\\.[a-zA-Z0-9._-]+\\)?\\|[rR]akefile\\)\\'")
#+end_src
**** zig-mode
#+begin_src emacs-lisp
  (use-package zig-mode
    :mode "\\.\\(zig\\|zon\\)\\'")
  (use-package zig-ts-mode
    :mode "\\.\\(zig\\|zon\\)\\'")
#+end_src
**** claude-code-ide
#+begin_src emacs-lisp
  (use-package claude-code-ide
    :ensure nil
    :bind ("C-c C-'" .
           claude-code-ide-menu) ; Set your favorite keybinding
    :config
    (setq claude-code-ide-mcp-server-port 52644)
    (claude-code-ide-emacs-tools-setup)) ; Optionally enable Emacs MCP tools
#+END_SRC
**** elisp
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :config
    (show-paren-mode 1)
    :hook
    (emacs-lisp-mode-hook . paredit-mode))
#+END_SRC
**** delimiters
#+begin_src emacs-lisp
  (electric-pair-mode 1)
#+end_src

*** nano modeline
#+BEGIN_SRC emacs-lisp
  (use-package nano-modeline
    :config
    (nano-modeline-text-mode t))
#+END_SRC


*** Text Editing
**** indentation and whitespace
***** aggressive indent
This package reindents the file being edited after every change. Pretty useful.
<2023-04-24 Mon> Removing this, it's hella annoying. I think if I had a projectile configuration per project it would be better.
#+begin_src emacs-lisp
  (use-package aggressive-indent
    :disabled t
    :config
    (global-aggressive-indent-mode 1))
#+end_src

***** Delete trailing whitespace
This deletes trailing whitespace when the buffer is saved.
#+begin_src emacs-lisp
  (defvar my/trailing-whitespace-modes '(markdown-mode)
    "List of modes where trailing whitespace should NOT be deleted.")

  (require 'cl-extra)

  (add-hook 'before-save-hook
            (lambda ()
              (unless (cl-some #'derived-mode-p my/trailing-whitespace-modes)
  	            (delete-trailing-whitespace))))
#+end_src

***** set tabs
Default tab settings, namely, no tabs, and also, a tab equaling four spaces.
#+begin_src emacs-lisp
  (setq tab-always-indent nil)
  (setq-default default-tab-width 2)
  (setq-default tab-width 2)
  (setq-default indent-tabs-mode nil)
#+end_src
**** Settings
***** Scrolling
#+begin_src emacs-lisp
  (setq scroll-conservatively scroll-margin)
  (setq scroll-step 1)
  (setq scroll-preserve-screen-position t)
  (setq scroll-error-top-bottom t)
  (setq mouse-wheel-progressive-speed nil)
  (setq mouse-wheel-inhibit-click-time nil)
#+end_src
***** Clipboard
#+begin_src emacs-lisp
  (setq select-enable-clipboard t)
  (setq mouse-yank-at-point t)
#+end_src

***** Backups
#+begin_src emacs-lisp
  (setq backup-inhibited t)
  (setq auto-save-default nil)
#+end_src

**** Undo Tree
Replaces Emacs built-in sequential undo system with a tree-based one. Probably one of the greatest options of Emacs as a text editor.

#+begin_src emacs-lisp
  (use-package undo-tree
    :config
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-diff t)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-auto-save-history nil)
    (fset 'undo-auto-amalgamate 'ignore)
    (setq undo-limit 6710886400)
    (setq undo-strong-limit 100663296)
    (setq undo-outer-limit 1006632960))

#+end_src
**** Move Text
allows for movement of text line under point, nifty
#+BEGIN_SRC emacs-lisp
  (use-package move-text
    :bind (
           ("M-n" . move-text-down)
           ("M-p" . move-text-up)))
#+END_SRC
*** Project Management
Packages related to managing projects and files.

**** dired-sidebar

Never heard of this until digging into sqrtminusone's config,
but seems like a nice lightweight replacement for Treemacs.
#+begin_src emacs-lisp
  (use-package dired-sidebar
    :bind (("C-x t t" . dired-sidebar-toggle-sidebar))

    :commands (dired-sidebar-toggle-sidebar)
    :init
    (add-hook 'dired-sidebar-mode-hook
              (lambda ()
                (unless (file-remote-p default-directory)
                  (auto-revert-mode))))
    :config
    (push 'toggle-window-split dired-sidebar-toggle-hidden-commands)
    (push 'rotate-windows dired-sidebar-toggle-hidden-commands)
    (setq dired-sidebar-subtree-line-prefix "__")
    (setq dired-sidebar-theme 'nerd)
    (setq dired-sidebar-use-term-integration t)
    (setq dired-sidebar-use-custom-font t))
#+end_src

**** Projectile
So necessary. Manages projects, git aware. IDK how you would use
Emacs efficiently without this.

11/19/2023: Turns out, project.el exists, and is quite good. In case
I come back to this and don't remember, the default prefix for project.el
keybinds in C-x p.
#+begin_src emacs-lisp
  (use-package projectile
    :disabled t
    :bind (:map projectile-mode-map
                ("C-c p" . projectile-command-map))
    :config
    (setq projectile-project-search-path '(("~/src/" . 2)))
    :init
    (projectile-mode +1))

  (use-package counsel-projectile
    :after (counsel projectile)
    )
#+end_src

**** Magit
Probably the most iconic Emacs program? Anyways, super good either way.
#+begin_src emacs-lisp
  (use-package magit
    :commands (magit-status magit-file-dispatch)
    :config
    (setq magit-refresh-status-buffer nil)
    (setq magit-blame-styles
          '((headings
             (heading-format . "%-20a %C %s\n"))
            (highlight
             (highlight-face . magit-blame-highlight))
            (lines
             (show-lines . t)
             (show-message . t)))))
#+end_src

**** Forge
Integrates with magit, used for integrations with github and the like.
#+begin_src emacs-lisp
  (use-package forge
    :after magit
    :defer t)
#+end_src

Copied from: https://github.com/magit/forge/discussions/544.
This adds a new auth-source that forge can use that taps into the gh-cli, which I always have installed.
#+begin_src emacs-lisp
  ;; =============================================================================
  ;; use gh-cli as auth-source for forge to workaround forbidden PAT access to organization
  ;; -----------------------------------------------------------------------------

  (cl-defun auth-source-ghcli-search (&rest spec
                                            &key backend require
                                            type max host user port
                                            &allow-other-keys)
    "Given a property list SPEC, return search matches from the `:backend'.
  See `auth-source-search' for details on SPEC."
    ;; just in case, check that the type is correct (null or same as the backend)
    (cl-assert (or (null type) (eq type (oref backend type)))
               t "Invalid GH CLI search: %s %s")

    (when-let* ((hostname (string-remove-prefix "api." host))
                ;; split ghub--ident again
                (ghub_ident (split-string user "\\^"))
                (username (car ghub_ident))
                (package (cadr ghub_ident))
                (cmd (format "gh auth token --hostname '%s'" hostname))
                (token (when (string= package "forge") (string-trim-right (shell-command-to-string cmd))))
                (retval (list
                         :host hostname
                         :user username
                         :secret token)))
      (auth-source-do-debug  "auth-source-ghcli: return %s as final result (plus hidden password)"
                             (seq-subseq retval 0 -2)) ;; remove password
      (list retval)))

  (defvar auth-source-ghcli-backend
    (auth-source-backend
     :source "." ;; not used
     :type 'gh-cli
     :search-function #'auth-source-ghcli-search)
    "Auth-source backend for GH CLI.")

  (defun auth-source-ghcli-backend-parse (entry)
    "Create a GH CLI auth-source backend from ENTRY."
    (when (eq entry 'gh-cli)
      (auth-source-backend-parse-parameters entry auth-source-ghcli-backend)))

  (if (boundp 'auth-source-backend-parser-functions)
      (add-hook 'auth-source-backend-parser-functions #'auth-source-ghcli-backend-parse)
    (advice-add 'auth-source-backend-parse :before-until #'auth-source-ghcli-backend-parse))
  (setq auth-sources '(gh-cli))
#+end_src

**** Git gutter
Make things pretty.
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :hook (prog-mode . git-gutter-mode)
    :config
    (setq git-gutter:update-interval 0.02))
  (use-package git-gutter-fringe
    :config
    (define-fringe-bitmap 'git-gutter-fr:added [224] nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:modified [224] nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:deleted [128 192 224 240] nil nil 'bottom))
#+END_SRC
**** Editing files
Remember recently edited files.
#+begin_src emacs-lisp
  (recentf-mode 1)
#+end_src

Save the most recently edited place in a file.
#+begin_src emacs-lisp
  (save-place-mode nil)
#+end_src
**** org-mode and org-agenda
#+begin_src emacs-lisp
  (use-package org
    :bind ("C-x a" . org-agenda)
    :config
    (setq org-agenda-files (list "~/src/femiagbabiaka/agenda")))
  (use-package org-modern
    :config
    (setq
     ;; Edit settings
     org-auto-align-tags nil
     org-tags-column 0
     org-catch-invisible-edits 'show-and-error
     org-special-ctrl-a/e t
     org-insert-heading-respect-content t

     ;; Org styling, hide markup etc.
     org-hide-emphasis-markers t
     org-pretty-entities t
     org-agenda-tags-column 0
     org-ellipsis "â€¦")

    (global-org-modern-mode))
#+end_src

*** Completion
This entire section is pretty much cargo culted. We'll see what works long term.
**** Vertico
Vertico is a completion framework that seeks to extend native Emacs     functionality.
#+begin_src emacs-lisp
  (use-package vertico
    :init (vertico-mode))
  (use-package vertico-posframe
    :requires vertico
    :init
    (vertico-posframe-mode 1)
    :config
    (add-to-list 'default-frame-alist '(resize-pixelwise . t))
    (setq frame-resize-pixelwise t)
    (setq vertico-posframe-truncate-lines t))
#+end_src

#+RESULTS:
: t

**** orderless
#+begin_src emacs-lisp
  (use-package orderless
    :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles basic partial-completion))))
    (completion-category-defaults nil)
    (completion-pcm-leading-wildcard t))
#+end_src

**** marginalia
#+begin_src emacs-lisp
  (use-package marginalia
    :config
    (marginalia-mode))
#+end_src

*** Feed reader
#+begin_src emacs-lisp
  (use-package elfeed
    :bind ("C-x w" . elfeed)
    :config
    (setq elfeed-feeds
          '(("https://www.ft.com/myft/following/943acc7c-45a4-4f0d-af09-03396f264621.rss" news)
            ("https://www.computerenhance.com/feed" programming))))
#+END_SRC
*** youtube feed reader
#+BEGIN_SRC emacs-lisp
  (use-package elfeed-tube
    :after elfeed
    :config
    ;; (setq elfeed-tube-auto-save-p nil) ; default value
    ;; (setq elfeed-tube-auto-fetch-p t)  ; default value
    (elfeed-tube-setup)
    (elfeed-tube-add-feeds '("https://youtube.com/@veritasium"
                             "jonhoo"
                             "netdevconf"
                             "XahLee"
                             "BillyEllis"
                             "trappuniversity"
                             "protesilaos"
                             "TsodingDaily"
                             "ALifeEngineered"))

    :bind (:map elfeed-show-mode-map
                ("F" . elfeed-tube-fetch)
                ([remap save-buffer] . elfeed-tube-save)
                :map elfeed-search-mode-map
                ("F" . elfeed-tube-fetch)
                ([remap save-buffer] . elfeed-tube-save)))
#+END_SRC

*** Terminal
#+BEGIN_SRC emacs-lisp
  (use-package vterm)
#+END_SRC
** UI Settings
*** Miscellaneous
Setup ansi-color mode.
#+BEGIN_SRC emacs-lisp
  (use-package ansi-color
    :ensure nil
    :hook (compilation-filter . ansi-color-compilation-filter))
#+END_SRC

Disable the annoying stuff.
#+begin_src emacs-lisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src

#+RESULTS:

Highlight the current line.
#+begin_src emacs-lisp
  (global-hl-line-mode 1)
#+end_src

Disable the start screen.
#+begin_src emacs-lisp
  (setq inhibit-startup-screen t)
#+end_src

Highlight the current line.
#+begin_src emacs-lisp
  (global-hl-line-mode 1)
#+end_src

*** Line numbers
Turn on line numbers mode.
Make line numbers absolute.
#+begin_src emacs-lisp
  (global-display-line-numbers-mode 1)
  (setq display-line-numbers-type 'relative)
#+end_src

*** Word wrapping
#+begin_src emacs-lisp
  (setq word-wrap 1)
  (global-visual-line-mode 1)
#+end_src

*** Olivetti
This package limits the text body width, super useful in visual mode.
#+begin_src emacs-lisp
  (use-package olivetti
    :if (display-graphic-p)
    :config
    (setq-default olivetti-body-width 86))
#+end_src

*** Icons
load all the icons on first boot only
#+begin_src emacs-lisp
  (use-package all-the-icons
    :if (display-graphic-p)
    )
#+end_src

*** epub reader
#+begin_src emacs-lisp
  (use-package nov
    :mode ("\\.epub\\'" . nov-mode)
    :hook (nov-mode . (lambda ()
                        (face-remap-add-relative 'shr-h1 :height 1.8 :weight 'bold)
                        (face-remap-add-relative 'shr-h2 :height 1.6 :weight 'bold)
                        (face-remap-add-relative 'shr-h3 :height 1.4 :weight 'bold)
                        (face-remap-add-relative 'shr-text :height 1.3)
                        (face-remap-add-relative 'shr-code :height 1.2)
                        (display-line-numbers-mode -1))))
#+end_src
