;;; -*- lexical-binding: t -*-
#+PROPERTY: header-args:emacs-lisp :tangle yes :lexical t
* Emacs Configuration.. semi-literate
** Packages
*** Custom file location
custom and the way it stores items in init.el is one of the dumber things
emacs does. well whatever, we move it
#+begin_src emacs-lisp
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (load custom-file 'noerror)
#+end_src

** Performance
*** Measuring startup speed
Function copied from sqrtminusone's config, measures emacs startup time.
#+begin_src emacs-lisp
  (defvar my/emacs-started nil
    "Flag to track whether Emacs has completed startup.")

  (add-hook 'emacs-startup-hook
            (lambda ()
              (message "*** Emacs loaded in %s with %d garbage collections."
  	                   (format "%.2f seconds"
  		                         (float-time
  			                        (time-subtract after-init-time before-init-time)))
  	                   gcs-done)
              (setq my/emacs-started t)))
#+end_src

*** Garbage collection
#+begin_src emacs-lisp
  (setq gc-cons-threshold 100000000)
  (setq read-process-output-max (* 1024 1024))
#+end_src

*** exec-path-from-shell
This conditionally sets the shell path based on the users configured shell path on boot.
Pretty good.
#+begin_src emacs-lisp
  (use-package exec-path-from-shell

    :init
    (require 'exec-path-from-shell)
    (dolist (var '("SSH_AUTH_SOCK" "SSH_AGENT_PID" "GPG_AGENT_INFO" "LANG" "LC_CTYPE" "NIX_SSL_CERT_FILE" "NIX_PATH"))
      (add-to-list 'exec-path-from-shell-variables var))
    (when (daemonp)
      (exec-path-from-shell-initialize))
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))
#+end_src

** Config Files
*** No littering
I actually didn't know about this package until reading through sqrtminusone's
emacs config. But uhh yeah, emacs leaves tmp files all over and it's annoying.
lets change that
#+begin_src emacs-lisp
  (use-package no-littering
    :demand t
    :init
    ;; Only load no-littering at runtime, not during byte-compilation
    (unless (bound-and-true-p byte-compile-current-file)
      (require 'no-littering)))
#+end_src

Turns out, there's a feature called file locking that's used for multi-user scenarios. That sucks.
#+begin_src emacs-lisp
  (setq lock-file-name-transforms
        '(("\\`/.*/\\([^/]+\\)\\'" "~/.emacs.d/.cache/\\1" t)))
  (setq auto-save-file-name-transforms
        '(("\\`/.*/\\([^/]+\\)\\'" "~/.emacs.d/.cache/\\1" t)))
  (setq backup-directory-alist
        '((".*" . "~/.emacs.d/.cache/")))
#+end_src
*** Make it harder to kill emacs
This will prompt us when we're going to kill Emacs.
#+begin_src emacs-lisp
  (unless (daemonp)
    (setq confirm-kill-emacs 'y-or-n-p))
#+end_src

** General settings
*** Emacs
#+begin_src emacs-lisp
  (use-package emacs
    :custom
    ;; Enable context menu. `vertico-multiform-mode' adds a menu in the minibuffer
    ;; to switch display modes.
    (context-menu-mode t)
    ;; Support opening new minibuffers from inside existing minibuffers.
    (enable-recursive-minibuffers t)
    ;; Hide commands in M-x which do not work in the current mode.  Vertico
    ;; commands are hidden in normal buffers. This setting is useful beyond
    ;; Vertico.
    (read-extended-command-predicate #'command-completion-default-include-p)
    ;; Do not allow the cursor in the minibuffer prompt
    (minibuffer-prompt-properties
     '(read-only t cursor-intangible t face minibuffer-prompt)))
#+end_src
*** Keybindings
**** which-key
A package that displays the available keybindings in a popup.
The package is pretty useful, as Emacs seems to have more keybindings than
I can remember at any given point.
#+begin_src emacs-lisp
  (use-package which-key
    :config
    (setq which-key-idle-delay 0.3)
    (setq which-key-popup-type 'frame)
    (which-key-mode)
    (which-key-setup-side-window-bottom)
    (set-face-attribute 'which-key-local-map-description-face nil
                        :weight 'bold)
    )
#+end_src

*** Theme
**** modus-theme
masterpiece of the one and only prot

#+begin_src emacs-lisp
  (use-package modus-themes
    :disabled t

    :config
    ;; Add all your customizations prior to loading the themes
    (setq modus-themes-italic-constructs t
          modus-themes-bold-constructs nil)

    ;; Maybe define some palette overrides, such as by using our presets
    (setq modus-themes-common-palette-overrides
          modus-themes-preset-overrides-intense)

    ;; Load the theme of your choice.
    (load-theme 'modus-vivendi)
    (define-key global-map (kbd "<f5>") #'modus-themes-toggle))
#+end_src

**** stimmung
#+BEGIN_SRC emacs-lisp
  (use-package stimmung-themes
    :custom
    (stimmung-themes-constant 'none)
    (stimmung-themes-type 'none :italic? t)
    (stimmung-themes-comment 'background :italic? nil)
    :config
    (setq-default mode-line-format nil))
;;    (stimmung-themes-load-dark))
#+END_SRC

**** nano
#+BEGIN_SRC emacs-lisp
  (use-package nano-theme
    :config
    (load-theme 'nano t))
#+END_SRC

**** Font
#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(font . "FiraCode Nerd Font Mono 16"))
  (set-face-attribute 'default        nil :family "FiraCode Nerd Font"            :height 120    :weight 'medium)
  (set-face-attribute 'fixed-pitch    nil :family "FiraCode Nerd Font"            :height 120    :weight 'medium)
  (set-face-attribute 'variable-pitch nil :family "FiraCode Nerd Font Mono" :height 120 :weight 'normal)
#+end_src


**** Default Frame Parameters
#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

**** Dashboard
#+begin_src emacs-lisp
  (use-package dashboard
    :config
    (dashboard-setup-startup-hook))
#+end_src

*** Programming Modes
**** nix
#+begin_src emacs-lisp
  (use-package nix-mode
    :hook (nix-mode . lsp-deferred))
#+end_src

**** Rust
***** rust-mode
#+begin_src emacs-lisp
  (use-package rust-mode

    :config
    (setq rust-format-on-save t)
    (add-hook 'rust-mode-hook (lambda () (setq indent-tabs-mode nil)))
    (add-hook 'rust-mode-hook (lambda () (prettify-symbols-mode))))
#+end_src

**** Fish Shell
#+begin_src emacs-lisp
  (use-package fish-mode
    :mode "\\.fish\\'")
#+end_src

**** Haskell
#+begin_src emacs-lisp
  (use-package haskell-mode
    :mode "\\.hs\\'")
#+end_src

**** Terraform
#+begin_src emacs-lisp
  (use-package terraform-mode

    :custom (terraform-format-on-save t)
    :config
    (defun my-terraform-mode-init ()
      ;; if you want to use outline-minor-mode
      (outline-minor-mode 1))
    (add-hook 'terraform-mode-hook 'my-terraform-mode-init))
#+end_src

**** Dockerfile
#+begin_src emacs-lisp
  (use-package dockerfile-mode)
#+end_src

**** Groovy
#+begin_src emacs-lisp
  (use-package groovy-mode)
#+end_src

**** LSP
#+begin_src emacs-lisp
  (use-package eglot

    :config
    ;; Ensure `nil` is in your PATH.
    (add-to-list 'eglot-server-programs '(nix-mode . ("nil")))
    :hook
    (nix-mode . eglot-ensure)
    (terraform-mode . eglot-ensure)
    (haskell-mode . eglot-ensure)
    (rust-mode . eglot-ensure)
    (fish-mode . eglot-ensure)
    (typescript-mode . eglot-ensure)
    (go-mode . eglot-ensure)
    (yaml-mode . eglot-ensure)
    (ruby-mode. eglot-ensure)
    (dockerfile-mode . eglot-ensure)
    (groovy-mode . eglot-ensure))
#+end_src

**** Flycheck
#+begin_src emacs-lisp
  (use-package flycheck
    :init (global-flycheck-mode))
  (use-package flycheck-eglot
    :after (flycheck eglot)
    :config (global-flycheck-eglot-mode 1))
#+end_src

**** Company Mode
#+begin_src emacs-lisp
  (use-package company
    :init (global-company-mode)
    :config
    (setq company-minimum-prefix-length 1
          company-idle-delay 0.0) ;; default is 0.2
    )
#+end_src

**** Typescript
#+begin_src emacs-lisp
  (use-package typescript-mode
    :mode "\\.ts\\'"
    :config
    (add-hook 'typescript-mode-hook #'hs-minor-mode))
#+end_src

**** go-mode
#+begin_src emacs-lisp
  (use-package go-mode
    :mode "\\.go\\'"
    :hook (before-save . gofmt-before-save)
    :custom (gofmt-command "goimports"))
#+end_src

**** yaml-mode
#+begin_src emacs-lisp
  (use-package yaml-mode
    :mode "\\.yml\\'")
#+end_src

**** ruby-mode
#+begin_src emacs-lisp
  (use-package ruby-mode
    :mode "\\.\\(?:cap\\|gemspec\\|irbrc\\|gemrc\\|rake\\|rb\\|ru\\|thor\\)\\'"
    :mode "\\(?:Brewfile\\|Capfile\\|Gemfile\\(?:\\.[a-zA-Z0-9._-]+\\)?\\|[rR]akefile\\)\\'")
#+end_src
**** zig-mode
#+begin_src emacs-lisp
  (use-package zig-mode
    :mode "\\.\\(zig\\|zon\\)\\'")
#+end_src
**** claude-code-ide
#+begin_src emacs-lisp
  (use-package claude-code-ide
    :bind ("C-c C-'" .
           claude-code-ide-menu) ; Set your favorite keybinding
    :config
    (setq claude-code-ide-mcp-server-port 52644)
    (claude-code-ide-emacs-tools-setup)) ; Optionally enable Emacs MCP tools
#+END_SRC
*** Doom Modeline
It looks cool, but IDK if I want to use it long term. Let's see!
#+begin_src emacs-lisp
  (use-package doom-modeline
    :disabled t
    :after all-the-icons
    :init
    (setq doom-modeline-env-enable-python nil)
    (setq doom-modeline-env-enable-go nil)
    (setq doom-modeline-buffer-encoding 'nondefault)
    (setq doom-modeline-hud t)
    (setq doom-modeline-persp-icon nil)
    (setq doom-modeline-persp-name nil)
    (setq doom-modeline-display-misc-in-all-mode-lines nil)
    (doom-modeline-mode 1)
    :config
    (setq doom-modeline-minor-modes nil)
    (setq doom-modeline-irc nil)
    (setq doom-modeline-buffer-state-icon nil))
#+end_src

*** nano modeline
#+BEGIN_SRC emacs-lisp
  (use-package nano-modeline
    :config
    (nano-modeline-text-mode t))
#+END_SRC


*** Text Editing
**** indentation and whitespace
***** aggressive indent
This package reindents the file being edited after every change. Pretty useful.
<2023-04-24 Mon> Removing this, it's hella annoying. I think if I had a projectile configuration per project it would be better.
#+begin_src emacs-lisp
  (use-package aggressive-indent
    :disabled t
    :config
    (global-aggressive-indent-mode 1))
#+end_src

***** Delete trailing whitespace
This deletes trailing whitespace when the buffer is saved.
#+begin_src emacs-lisp
  (defvar my/trailing-whitespace-modes '(markdown-mode)
    "List of modes where trailing whitespace should NOT be deleted.")

  (require 'cl-extra)

  (add-hook 'before-save-hook
            (lambda ()
              (unless (cl-some #'derived-mode-p my/trailing-whitespace-modes)
  	            (delete-trailing-whitespace))))
#+end_src

***** set tabs
Default tab settings, namely, no tabs, and also, a tab equaling four spaces.
#+begin_src emacs-lisp
  (setq tab-always-indent nil)
  (setq-default default-tab-width 2)
  (setq-default tab-width 2)
  (setq-default indent-tabs-mode nil)
#+end_src
**** Settings
***** Scrolling
#+begin_src emacs-lisp
  (setq scroll-conservatively scroll-margin)
  (setq scroll-step 1)
  (setq scroll-preserve-screen-position t)
  (setq scroll-error-top-bottom t)
  (setq mouse-wheel-progressive-speed nil)
  (setq mouse-wheel-inhibit-click-time nil)
#+end_src
***** Clipboard
#+begin_src emacs-lisp
  (setq select-enable-clipboard t)
  (setq mouse-yank-at-point t)
#+end_src

***** Backups
#+begin_src emacs-lisp
  (setq backup-inhibited t)
  (setq auto-save-default nil)
#+end_src

**** Undo Tree
Replaces Emacs built-in sequential undo system with a tree-based one. Probably one of the greatest options of Emacs as a text editor.

#+begin_src emacs-lisp
  (use-package undo-tree
    :config
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-diff t)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-auto-save-history nil)
    (fset 'undo-auto-amalgamate 'ignore)
    (setq undo-limit 6710886400)
    (setq undo-strong-limit 100663296)
    (setq undo-outer-limit 1006632960))

#+end_src
**** Move Text
allows for movement of text line under point, nifty
#+BEGIN_SRC emacs-lisp
  (use-package move-text
    :bind (
           ("M-n" . move-text-down)
           ("M-p" . move-text-up)))
#+END_SRC
*** Project Management
Packages related to managing projects and files.

**** dired-sidebar

Never heard of this until digging into sqrtminusone's config,
but seems like a nice lightweight replacement for Treemacs.
#+begin_src emacs-lisp
  (use-package dired-sidebar
    :bind (("C-x t t" . dired-sidebar-toggle-sidebar))

    :commands (dired-sidebar-toggle-sidebar)
    :init
    (add-hook 'dired-sidebar-mode-hook
              (lambda ()
                (unless (file-remote-p default-directory)
                  (auto-revert-mode))))
    :config
    (push 'toggle-window-split dired-sidebar-toggle-hidden-commands)
    (push 'rotate-windows dired-sidebar-toggle-hidden-commands)
    (setq dired-sidebar-subtree-line-prefix "__")
    (setq dired-sidebar-theme 'nerd)
    (setq dired-sidebar-use-term-integration t)
    (setq dired-sidebar-use-custom-font t))
#+end_src

**** Projectile
So necessary. Manages projects, git aware. IDK how you would use
Emacs efficiently without this.

11/19/2023: Turns out, project.el exists, and is quite good. In case
I come back to this and don't remember, the default prefix for project.el
keybinds in C-x p.
#+begin_src emacs-lisp
  (use-package projectile
    :disabled t
    :bind (:map projectile-mode-map
                ("C-c p" . projectile-command-map))
    :config
    (setq projectile-project-search-path '(("~/src/" . 2)))
    :init
    (projectile-mode +1))

  (use-package counsel-projectile
    :after (counsel projectile)
    )
#+end_src

**** Magit
Probably the most iconic Emacs program? Anyways, super good either way.
#+begin_src emacs-lisp
  (use-package magit
    :commands (magit-status magit-file-dispatch)
    :config
    (setq magit-refresh-status-buffer nil)
    (setq magit-blame-styles
          '((headings
             (heading-format . "%-20a %C %s\n"))
            (highlight
             (highlight-face . magit-blame-highlight))
            (lines
             (show-lines . t)
             (show-message . t)))))
#+end_src

**** Forge
Integrates with magit, used for integrations with github and the like.
#+begin_src emacs-lisp
  (use-package forge
    :after magit
    :defer t)
#+end_src

Copied from: https://github.com/magit/forge/discussions/544.
This adds a new auth-source that forge can use that taps into the gh-cli, which I always have installed.
#+begin_src emacs-lisp
  ;; =============================================================================
  ;; use gh-cli as auth-source for forge to workaround forbidden PAT access to organization
  ;; -----------------------------------------------------------------------------

  (cl-defun auth-source-ghcli-search (&rest spec
                                            &key backend require
                                            type max host user port
                                            &allow-other-keys)
    "Given a property list SPEC, return search matches from the `:backend'.
  See `auth-source-search' for details on SPEC."
    ;; just in case, check that the type is correct (null or same as the backend)
    (cl-assert (or (null type) (eq type (oref backend type)))
               t "Invalid GH CLI search: %s %s")

    (when-let* ((hostname (string-remove-prefix "api." host))
                ;; split ghub--ident again
                (ghub_ident (split-string user "\\^"))
                (username (car ghub_ident))
                (package (cadr ghub_ident))
                (cmd (format "gh auth token --hostname '%s'" hostname))
                (token (when (string= package "forge") (string-trim-right (shell-command-to-string cmd))))
                (retval (list
                         :host hostname
                         :user username
                         :secret token)))
      (auth-source-do-debug  "auth-source-ghcli: return %s as final result (plus hidden password)"
                             (seq-subseq retval 0 -2)) ;; remove password
      (list retval)))

  (defvar auth-source-ghcli-backend
    (auth-source-backend
     :source "." ;; not used
     :type 'gh-cli
     :search-function #'auth-source-ghcli-search)
    "Auth-source backend for GH CLI.")

  (defun auth-source-ghcli-backend-parse (entry)
    "Create a GH CLI auth-source backend from ENTRY."
    (when (eq entry 'gh-cli)
      (auth-source-backend-parse-parameters entry auth-source-ghcli-backend)))

  (if (boundp 'auth-source-backend-parser-functions)
      (add-hook 'auth-source-backend-parser-functions #'auth-source-ghcli-backend-parse)
    (advice-add 'auth-source-backend-parse :before-until #'auth-source-ghcli-backend-parse))
  (setq auth-sources '(gh-cli))
#+end_src

**** Git gutter
Make things pretty.
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :hook (prog-mode . git-gutter-mode)
    :config
    (setq git-gutter:update-interval 0.02))
  (use-package git-gutter-fringe
    :config
    (define-fringe-bitmap 'git-gutter-fr:added [224] nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:modified [224] nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:deleted [128 192 224 240] nil nil 'bottom))
#+END_SRC
**** Editing files
Remember recently edited files.
#+begin_src emacs-lisp
  (recentf-mode 1)
#+end_src

Save the most recently edited place in a file.
#+begin_src emacs-lisp
  (save-place-mode nil)
#+end_src

*** Completion
This entire section is pretty much cargo culted. We'll see what works long term.
**** Vertico
Vertico is a completion framework that seeks to extend native Emacs     functionality.
#+begin_src emacs-lisp
  (use-package vertico
    :init (vertico-mode))
  (use-package vertico-posframe
    :requires vertico
    :init
    (vertico-posframe-mode 1))
#+end_src

**** orderless
#+begin_src emacs-lisp
  (use-package orderless
    :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles basic partial-completion))))
    (completion-category-defaults nil)
    (completion-pcm-leading-wildcard t))
#+end_src

**** marginalia
#+begin_src emacs-lisp
  (use-package marginalia
    :config
    (marginalia-mode))
#+end_src

*** Feed reader
#+begin_src emacs-lisp
    (use-package elfeed
      :bind ("C-x w" . elfeed)
      :config
      (setq elfeed-feeds
            '(("https://www.ft.com/myft/following/943acc7c-45a4-4f0d-af09-03396f264621.rss" news)
              ("https://www.computerenhance.com/feed" programming))))
#+END_SRC
*** youtube feed reader
#+BEGIN_SRC emacs-lisp
                  (use-package elfeed-tube
                    :after elfeed
                    :config
                    ;; (setq elfeed-tube-auto-save-p nil) ; default value
                    ;; (setq elfeed-tube-auto-fetch-p t)  ; default value
                    (elfeed-tube-setup)
                    (elfeed-tube-add-feeds '("https://youtube.com/@veritasium"
                                             "jonhoo"
                                             "netdevconf"
                                             "XahLee"
                                             "BillyEllis"
                                             "trappuniversity"
                                             "protesilaos"
                                             "TsodingDaily"
                                             "ALifeEngineered"))

                    :bind (:map elfeed-show-mode-map
                                ("F" . elfeed-tube-fetch)
                                ([remap save-buffer] . elfeed-tube-save)
                                :map elfeed-search-mode-map
                                ("F" . elfeed-tube-fetch)
                                ([remap save-buffer] . elfeed-tube-save)))
#+END_SRC

*** Terminal
#+BEGIN_SRC emacs-lisp
  (use-package vterm)
#+END_SRC
** UI Settings
*** Miscellaneous
Disable the annoying stuff.
#+begin_src emacs-lisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src

Highlight the current line.
#+begin_src emacs-lisp
  (global-hl-line-mode 1)
#+end_src

Disable the start screen.
#+begin_src emacs-lisp
  (setq inhibit-startup-screen t)
#+end_src

Highlight the current line.
#+begin_src emacs-lisp
  (global-hl-line-mode 1)
#+end_src

*** Line numbers
Turn on line numbers mode.
Make line numbers absolute.
#+begin_src emacs-lisp
  (global-display-line-numbers-mode 1)
  (setq display-line-numbers-type 'relative)
#+end_src


*** Word wrapping
#+begin_src emacs-lisp
  (setq word-wrap 1)
  (global-visual-line-mode 1)
#+end_src

*** Olivetti
This package limits the text body width, super useful in visual mode.
#+begin_src emacs-lisp
  (use-package olivetti
    :if (display-graphic-p)
    :config
    (setq-default olivetti-body-width 86))
#+end_src

*** Icons
load all the icons on first boot only
#+begin_src emacs-lisp
  (use-package all-the-icons
    :if (display-graphic-p)
    )
#+end_src

*** epub reader
#+begin_src emacs-lisp
  (use-package nov
    )
#+end_src
